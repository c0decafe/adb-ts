/// <reference types="node" />
import { AdbClientOptions, CommandConstruct, CpOptions, ForwardsObject, IAdbDevice, InputOptions, InputSource, InstallOptions, KeyStringObject, LogcatOptions, MkDirOptions, MvOptions, ReversesObject, RmOption, SettingsMode, SimpleType, StartActivityOptions, StartServiceOptions, TouchOptions, TransportType, UninstallOptions, WaitForState } from '.';
import { SyncMode } from './sync';
import { Stats } from 'fs';
import AdbDevice from './device';
import Connection from './connection';
import { EventEmitter } from 'events';
import FileStats from './filestats';
import Jimp from 'jimp';
import { KeyCode } from './keycode';
import LogcatReader from './logcat/reader';
import Monkey from './monkey/client';
import Promise from 'bluebird';
import PullTransfer from './sync/pulltransfer';
import PushTransfer from './sync/pushtransfer';
import { Readable } from 'stream';
import SyncEntry from './sync/entry';
import Tracker from './tracker';
export default class AdbClient extends EventEmitter {
    private options;
    constructor(options?: AdbClientOptions);
    startServer(cb?: (err: Error) => void): Promise<void>;
    private connection;
    transport(serial: string): Promise<Connection>;
    version(cb?: (err: Error, value?: number) => void): Promise<number>;
    connect(host: string, cb?: (err: Error, value: number) => void): Promise<string>;
    connect(host: string, port?: number, cb?: (err: Error, value: number) => void): Promise<string>;
    disconnect(host: string, cb?: (err: Error, value: number) => void): Promise<string>;
    disconnect(host: string, port?: number, cb?: (err: Error, value: number) => void): Promise<string>;
    listDevices(cb?: (err: Error, value: IAdbDevice[]) => void): Promise<IAdbDevice[]>;
    trackDevices(cb?: (err: Error, value: Tracker) => void): Promise<Tracker>;
    kill(cb?: (err: Error) => void): Promise<void>;
    getSerialNo(serial: string, cb?: (err: Error, value: string) => void): Promise<string | number | boolean>;
    getDevicePath(serial: string, cb?: (err: Error, value: string) => void): Promise<string>;
    listProperties(serial: string, cb?: (err: Error, value: KeyStringObject) => void): Promise<KeyStringObject>;
    listFeatures(serial: string, cb?: (err: Error, value: KeyStringObject) => void): Promise<KeyStringObject>;
    listPackages(serial: string, cb?: (err: Error, value: string[]) => void): Promise<string[]>;
    getIpAddress(serial: string, cb?: (err: Error, value: string) => void): Promise<string | undefined>;
    forward(serial: string, local: string, remote: string, cb?: (err: Error) => void): Promise<void>;
    listForwards(serial: string, cb?: (err: Error, value: ForwardsObject[]) => void): Promise<ForwardsObject[]>;
    reverse(serial: string, local: string, remote: string, cb?: (err: Error) => void): Promise<void>;
    listReverses(serial: string, cb?: (err: Error, value: ReversesObject[]) => void): Promise<ReversesObject[]>;
    private shellInternal;
    reboot(serial: string, cb?: (err: Error) => void): Promise<void>;
    shutdown(serial: string, cb?: (err: Error) => void): Promise<void>;
    remount(serial: string, cb?: (err: Error) => void): Promise<void>;
    root(serial: string, cb?: (err: Error) => void): Promise<void>;
    screenshot(serial: string, cb?: (err: Error, value: Jimp) => void): Promise<Jimp>;
    openTcp(serial: string, port: number | string, cb?: (err: Error, value: Connection) => void): Promise<Connection>;
    openTcp(serial: string, port: number | string, host?: string, cb?: (err: Error, value: Connection) => void): Promise<Connection>;
    roll(serial: string, x: number, y: number, cb?: (err: Error) => void): Promise<void>;
    roll(serial: string, x: number, y: number, source?: InputSource, cb?: (err: Error) => void): Promise<void>;
    press(serial: string, cb?: (err: Error) => void): Promise<void>;
    press(serial: string, source?: InputSource, cb?: (err: Error) => void): Promise<void>;
    dragAndDrop(serial: string, x1: number, y1: number, x2: number, y2: number, cb?: (err: Error) => void): Promise<void>;
    dragAndDrop(serial: string, x1: number, y1: number, x2: number, y2: number, options?: InputOptions & {
        duration?: number;
    }, cb?: (err: Error) => void): Promise<void>;
    swipe(serial: string, x1: number, y1: number, x2: number, y2: number, cb?: (err: Error) => void): Promise<void>;
    swipe(serial: string, x1: number, y1: number, x2: number, y2: number, options?: InputOptions & {
        duration?: number;
    }, cb?: (err: Error) => void): Promise<void>;
    keyEvent(serial: string, code: KeyCode | number, cb?: (err: Error) => void): Promise<void>;
    keyEvent(serial: string, code: KeyCode | number, options?: InputOptions & {
        longpress?: boolean;
    }, cb?: (err: Error) => void): Promise<void>;
    tap(serial: string, x: number, y: number, cb?: (err: Error) => void): Promise<void>;
    tap(serial: string, x: number, y: number, source: InputSource, cb?: (err: Error) => void): Promise<void>;
    text(serial: string, text: SimpleType, cb?: (err: Error) => void): Promise<void>;
    text(serial: string, text: SimpleType, source: InputSource, cb?: (err: Error) => void): Promise<void>;
    openLogcat(serial: string, cb?: (err: Error, value: LogcatReader) => void): Promise<LogcatReader>;
    openLogcat(serial: string, options?: LogcatOptions, cb?: (err: Error, value: LogcatReader) => void): Promise<LogcatReader>;
    private syncService;
    clear(serial: string, pkg: string, cb?: (err: Error) => void): Promise<void>;
    private installRemote;
    install(serial: string, apk: string | Readable, cb?: (err: Error) => void): Promise<void>;
    install(serial: string, apk: string | Readable, options?: InstallOptions, cb?: (err: Error) => void): Promise<void>;
    install(serial: string, apk: string | Readable, options?: InstallOptions, args?: string, cb?: (err: Error) => void): Promise<void>;
    uninstall(serial: string, pkg: string, cb?: (err: Error) => void): Promise<void>;
    uninstall(serial: string, pkg: string, options?: UninstallOptions, cb?: (err: Error) => void): Promise<void>;
    isInstalled(serial: string, pkg: string, cb?: (err: Error, value: boolean) => void): Promise<boolean>;
    startActivity(serial: string, pkg: string, activity: string, cb?: (err: Error) => void): Promise<void>;
    startActivity(serial: string, pkg: string, activity: string, options?: StartActivityOptions, cb?: (err: Error) => void): Promise<void>;
    startService(serial: string, pkg: string, service: string, cb?: (err: Error) => void): any;
    startService(serial: string, pkg: string, service: string, options?: StartServiceOptions, cb?: (err: Error) => void): Promise<void>;
    stat(serial: string, path: string, cb?: (err: Error, value: Stats) => void): Promise<import("./sync/stats").default>;
    readDir(serial: string, path: string, cb?: (err: Error, value: SyncEntry[]) => void): Promise<SyncEntry[]>;
    pull(serial: string, path: string, cb?: (err: Error, value: PullTransfer) => void): Promise<PullTransfer>;
    push(serial: string, srcPath: string | Readable, destPath: string, cb?: (err: Error, value: PushTransfer) => void): Promise<PushTransfer>;
    push(serial: string, srcPath: string | Readable, destPath: string, mode?: SyncMode, cb?: (err: Error, value: PushTransfer) => void): Promise<PushTransfer>;
    tcpip(serial: string, cb?: (err: Error, value: string) => void): Promise<string>;
    tcpip(serial: string, port: number, cb?: (err: Error, value: string) => void): Promise<string>;
    usb(serial: string, cb?: (err: Error) => void): Promise<void>;
    waitBootComplete(serial: string, cb?: (err: Error) => void): Promise<void>;
    waitForDevice(tranport: TransportType, state: WaitForState, cb?: (err: Error) => void): Promise<void>;
    map<R>(mapper: (device: AdbDevice) => R): Promise<R[]>;
    private pushInternal;
    pushDataToFile(serial: string, data: string, destPath: string, cb?: (err: Error) => void): Promise<void>;
    pushFile(serial: string, srcPath: string, destPath: string, cb?: (err: Error) => void): Promise<void>;
    pullDataFromFile(serial: string, srcPath: string, cb?: (err: Error, value: string) => void): Promise<string>;
    pullFile(serial: string, srcPath: string, destPath: string, cb?: (err: Error) => void): Promise<void>;
    setProp(serial: string, prop: string, value: SimpleType, cb?: (err: Error) => void): Promise<void>;
    getProp(serial: string, prop: string, cb?: (err: Error, value: SimpleType) => void): Promise<string | number | boolean>;
    putSetting(serial: string, mode: SettingsMode, name: string, value: SimpleType, cb?: (err: Error) => void): Promise<void>;
    listSettings(serial: string, mode: SettingsMode, cb?: (err: Error, value: KeyStringObject) => void): Promise<KeyStringObject>;
    getSetting(serial: string, mode: SettingsMode, name: string, cb?: (err: Error, value: SimpleType) => void): Promise<string | number | boolean>;
    shell(serial: string, command: string | string[], cb?: (err: Error, value: SimpleType) => void): Promise<string | number | boolean>;
    custom<T>(CustomCommand: CommandConstruct, cb?: (err: Error, value: T) => void): Promise<T>;
    customTransport<T>(CustomCommand: CommandConstruct, serial: string, cb?: (err: Error, value: T) => void): Promise<T>;
    openMonkey(serial: string, cb?: (err: Error, value: Monkey) => void): Promise<Monkey>;
    killApp(serial: string, pkg: string, cb?: (err: Error) => void): void;
    private execInternal;
    exec(cmd: string, cb?: (err: Error, value: string) => void): Promise<string>;
    execDevice(serial: string, cmd: string, cb?: (err: Error, value: string) => void): Promise<string>;
    execDeviceShell(serial: string, cmd: string, cb?: (err: Error, value: string) => void): Promise<string>;
    batteryStatus(serial: string, cb?: (err: Error, value: KeyStringObject) => void): Promise<KeyStringObject>;
    rm(serial: string, path: string, cb?: (err: Error | null, value: string) => void): Promise<string>;
    rm(serial: string, path: string, options?: RmOption, cb?: (err: Error | null, value: string) => void): Promise<string>;
    mkdir(serial: string, path: string, cb?: (err: Error | null, value: string) => void): Promise<string>;
    mkdir(serial: string, path: string, options?: MkDirOptions, cb?: (err: Error | null, value: string) => void): Promise<string>;
    touch(serial: string, path: string, cb?: (err: Error | null, value: string) => void): Promise<string>;
    touch(serial: string, path: string, options?: TouchOptions, cb?: (err: Error | null, value: string) => void): Promise<string>;
    mv(serial: string, srcPath: string, destPath: string, cb?: (err: Error | null, value: string) => void): Promise<string>;
    mv(serial: string, srcPath: string, destPath: string, options?: MvOptions, cb?: (err: Error | null, value: string) => void): Promise<string>;
    cp(serial: string, srcPath: string, destPath: string, cb?: (err: Error | null, value: string) => void): Promise<string>;
    cp(serial: string, srcPath: string, destPath: string, options?: CpOptions, cb?: (err: Error | null, value: string) => void): Promise<string>;
    fileStat(serial: string, path: string, cb?: (err: Error | null, value: FileStats) => void): Promise<FileStats>;
}
